<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>typescript基本使用 | 喋喋不休</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/blog/img/favicon.ico">
    <meta name="description" content="web前端技术博客,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,React,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/blog/assets/css/0.styles.0ab00a34.css" as="style"><link rel="preload" href="/blog/assets/js/app.c4ef267f.js" as="script"><link rel="preload" href="/blog/assets/js/2.738e1f2a.js" as="script"><link rel="preload" href="/blog/assets/js/76.d305a829.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.2c0458cd.js"><link rel="prefetch" href="/blog/assets/js/11.e3a0d22a.js"><link rel="prefetch" href="/blog/assets/js/12.9917dc45.js"><link rel="prefetch" href="/blog/assets/js/13.e22599fd.js"><link rel="prefetch" href="/blog/assets/js/14.0c30111e.js"><link rel="prefetch" href="/blog/assets/js/15.c3f7494e.js"><link rel="prefetch" href="/blog/assets/js/16.3fcb50ee.js"><link rel="prefetch" href="/blog/assets/js/17.b1404766.js"><link rel="prefetch" href="/blog/assets/js/18.8cd6b941.js"><link rel="prefetch" href="/blog/assets/js/19.6b40e37c.js"><link rel="prefetch" href="/blog/assets/js/20.c75bf095.js"><link rel="prefetch" href="/blog/assets/js/21.a9f8582a.js"><link rel="prefetch" href="/blog/assets/js/22.7b573753.js"><link rel="prefetch" href="/blog/assets/js/23.1815712d.js"><link rel="prefetch" href="/blog/assets/js/24.ce7aac26.js"><link rel="prefetch" href="/blog/assets/js/25.49012359.js"><link rel="prefetch" href="/blog/assets/js/26.f19ccc34.js"><link rel="prefetch" href="/blog/assets/js/27.6ad79311.js"><link rel="prefetch" href="/blog/assets/js/28.270b8658.js"><link rel="prefetch" href="/blog/assets/js/29.7668d420.js"><link rel="prefetch" href="/blog/assets/js/3.236be273.js"><link rel="prefetch" href="/blog/assets/js/30.3876f396.js"><link rel="prefetch" href="/blog/assets/js/31.d0bbfa7b.js"><link rel="prefetch" href="/blog/assets/js/32.75da0adf.js"><link rel="prefetch" href="/blog/assets/js/33.f479f660.js"><link rel="prefetch" href="/blog/assets/js/34.82ba7ce0.js"><link rel="prefetch" href="/blog/assets/js/35.c4302df3.js"><link rel="prefetch" href="/blog/assets/js/36.2ff90836.js"><link rel="prefetch" href="/blog/assets/js/37.a06e4fd5.js"><link rel="prefetch" href="/blog/assets/js/38.15e5e07c.js"><link rel="prefetch" href="/blog/assets/js/39.785cfa06.js"><link rel="prefetch" href="/blog/assets/js/4.0cd1bf26.js"><link rel="prefetch" href="/blog/assets/js/40.d4aad722.js"><link rel="prefetch" href="/blog/assets/js/41.a4d199ad.js"><link rel="prefetch" href="/blog/assets/js/42.23a4bf12.js"><link rel="prefetch" href="/blog/assets/js/43.b4945be0.js"><link rel="prefetch" href="/blog/assets/js/44.e3718d8d.js"><link rel="prefetch" href="/blog/assets/js/45.dec26f0f.js"><link rel="prefetch" href="/blog/assets/js/46.e9db7425.js"><link rel="prefetch" href="/blog/assets/js/47.318560ab.js"><link rel="prefetch" href="/blog/assets/js/48.b6b8edfd.js"><link rel="prefetch" href="/blog/assets/js/49.2f05be73.js"><link rel="prefetch" href="/blog/assets/js/5.a9f82c9e.js"><link rel="prefetch" href="/blog/assets/js/50.3ac3cd68.js"><link rel="prefetch" href="/blog/assets/js/51.c2125575.js"><link rel="prefetch" href="/blog/assets/js/52.20790822.js"><link rel="prefetch" href="/blog/assets/js/53.9934e45c.js"><link rel="prefetch" href="/blog/assets/js/54.2ff72a9e.js"><link rel="prefetch" href="/blog/assets/js/55.02caf8f7.js"><link rel="prefetch" href="/blog/assets/js/56.c4108588.js"><link rel="prefetch" href="/blog/assets/js/57.e636f582.js"><link rel="prefetch" href="/blog/assets/js/58.64aec83b.js"><link rel="prefetch" href="/blog/assets/js/59.dfa4219b.js"><link rel="prefetch" href="/blog/assets/js/6.6796d84f.js"><link rel="prefetch" href="/blog/assets/js/60.a7844f11.js"><link rel="prefetch" href="/blog/assets/js/61.284f83f7.js"><link rel="prefetch" href="/blog/assets/js/62.b590f762.js"><link rel="prefetch" href="/blog/assets/js/63.9cc34cf7.js"><link rel="prefetch" href="/blog/assets/js/64.d0701f7c.js"><link rel="prefetch" href="/blog/assets/js/65.f69ff84f.js"><link rel="prefetch" href="/blog/assets/js/66.fc2f4a94.js"><link rel="prefetch" href="/blog/assets/js/67.8d1e0a10.js"><link rel="prefetch" href="/blog/assets/js/68.71bd7d4a.js"><link rel="prefetch" href="/blog/assets/js/69.55f4e75e.js"><link rel="prefetch" href="/blog/assets/js/7.c682bfe8.js"><link rel="prefetch" href="/blog/assets/js/70.a221c048.js"><link rel="prefetch" href="/blog/assets/js/71.aed9d95a.js"><link rel="prefetch" href="/blog/assets/js/72.00e95be7.js"><link rel="prefetch" href="/blog/assets/js/73.bca16040.js"><link rel="prefetch" href="/blog/assets/js/74.5bfa09de.js"><link rel="prefetch" href="/blog/assets/js/75.71225d47.js"><link rel="prefetch" href="/blog/assets/js/77.5a94f89d.js"><link rel="prefetch" href="/blog/assets/js/78.f6c1bbd7.js"><link rel="prefetch" href="/blog/assets/js/79.50e373af.js"><link rel="prefetch" href="/blog/assets/js/8.771772df.js"><link rel="prefetch" href="/blog/assets/js/80.ceb50170.js"><link rel="prefetch" href="/blog/assets/js/81.b3bfdfb4.js"><link rel="prefetch" href="/blog/assets/js/82.1a4e2c10.js"><link rel="prefetch" href="/blog/assets/js/83.0b087ba9.js"><link rel="prefetch" href="/blog/assets/js/84.3c034cf9.js"><link rel="prefetch" href="/blog/assets/js/85.5826af50.js"><link rel="prefetch" href="/blog/assets/js/86.b38b6a10.js"><link rel="prefetch" href="/blog/assets/js/87.0b21a55d.js"><link rel="prefetch" href="/blog/assets/js/88.7375a4ba.js"><link rel="prefetch" href="/blog/assets/js/9.ce6e67b0.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.0ab00a34.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu have-body-img"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/img/logo.png" alt="喋喋不休" class="logo"> <span class="site-name can-hide">喋喋不休</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/blog/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/blog/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-subitem"><a href="/blog/pages/df9e7c7214fa5046/" class="nav-link">CSS</a></li></ul></li><li class="dropdown-item"><h4>三方库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/2c78e7/" class="nav-link">vue</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/blog/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/blog/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/blog/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/blog/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/baaa02/" class="nav-link">实用技巧</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="收藏" class="dropdown-title"><a href="/blog/pages/beb6c0bd8a66cea6/" class="link-title">收藏</a> <span class="title" style="display:none;">收藏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/pages/beb6c0bd8a66cea6/" class="nav-link">网站</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/blog/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/blog/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/blog/archives/" class="nav-link">归档</a></li><li class="dropdown-item"><!----> <a href="/blog/about/" class="nav-link">关于</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/logo.png"> <div class="blogger-info"><h3>Alan0827</h3> <span>扯淡的玩意er。。</span></div></div> <nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/blog/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/blog/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-subitem"><a href="/blog/pages/df9e7c7214fa5046/" class="nav-link">CSS</a></li></ul></li><li class="dropdown-item"><h4>三方库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/pages/2c78e7/" class="nav-link">vue</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/note/js/" class="nav-link">《JavaScript高级程序设计》</a></li><li class="dropdown-subitem"><a href="/blog/pages/51afd6/" class="nav-link">TypeScript</a></li><li class="dropdown-subitem"><a href="/blog/pages/4643cd/" class="nav-link">JS设计模式总结</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/blog/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/blog/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/blog/pages/baaa02/" class="nav-link">实用技巧</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="收藏" class="dropdown-title"><a href="/blog/pages/beb6c0bd8a66cea6/" class="link-title">收藏</a> <span class="title" style="display:none;">收藏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/pages/beb6c0bd8a66cea6/" class="nav-link">网站</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/blog/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/blog/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/blog/archives/" class="nav-link">归档</a></li><li class="dropdown-item"><!----> <a href="/blog/about/" class="nav-link">关于</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>typescript基本使用</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/pages/53eff0/#typescript-特性" class="sidebar-link">TypeScript 特性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/53eff0/#typescript是静态类型" class="sidebar-link">TypeScript是静态类型</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/53eff0/#typescript是弱类型" class="sidebar-link">TypeScript是弱类型</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/53eff0/#适用于任何规模" class="sidebar-link">适用于任何规模</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/53eff0/#与标准同步发展" class="sidebar-link">与标准同步发展</a></li></ul></li><li><a href="/blog/pages/53eff0/#安装typescript" class="sidebar-link">安装TypeScript</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/pages/53eff0/#基础" class="sidebar-link">基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/blog/pages/53eff0/#原始数据类型" class="sidebar-link">原始数据类型</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_1-布尔值" class="sidebar-link">1.布尔值</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_2-数值" class="sidebar-link">2.数值</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_3-字符串" class="sidebar-link">3.字符串</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_4-空值" class="sidebar-link">4.空值</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_5-null-和-undefined" class="sidebar-link">5.Null 和 Undefined</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/53eff0/#任意值" class="sidebar-link">任意值</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/53eff0/#类型推论" class="sidebar-link">类型推论</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/53eff0/#联合类型" class="sidebar-link">联合类型</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/53eff0/#对象的类型-接口" class="sidebar-link">对象的类型——接口</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_1-可选属性" class="sidebar-link">1.可选属性</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_2-任意属性" class="sidebar-link">2.任意属性</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_3-只读属性" class="sidebar-link">3.只读属性</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/53eff0/#数组的类型" class="sidebar-link">数组的类型</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_1-类型-方括号" class="sidebar-link">1.类型 + 方括号</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_2-数组泛型" class="sidebar-link">2.数组泛型</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_3-用接口表示数组" class="sidebar-link">3.用接口表示数组</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_4-类数组" class="sidebar-link">4.类数组</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_5-any-在数组中的应用" class="sidebar-link">5.any 在数组中的应用</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/53eff0/#函数的类型" class="sidebar-link">函数的类型</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_1-函数声明" class="sidebar-link">1.函数声明</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_2-函数表达式" class="sidebar-link">2.函数表达式</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_3-用接口定义函数的形状" class="sidebar-link">3.用接口定义函数的形状</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_4-可选参数" class="sidebar-link">4.可选参数</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_5-参数默认值" class="sidebar-link">5.参数默认值</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_6-剩余参数" class="sidebar-link">6.剩余参数</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_7-重载" class="sidebar-link">7.重载</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/53eff0/#类型断言" class="sidebar-link">类型断言</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_1-语法" class="sidebar-link">1.语法</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_2-类型断言的用途" class="sidebar-link">2.类型断言的用途</a></li><li class="sidebar-sub-header level5"><a href="/blog/pages/53eff0/#_1-将一个联合类型断言为其中一个类型" class="sidebar-link">1）将一个联合类型断言为其中一个类型</a></li><li class="sidebar-sub-header level5"><a href="/blog/pages/53eff0/#_2-将一个父类断言为更加具体的子类" class="sidebar-link">2）将一个父类断言为更加具体的子类</a></li><li class="sidebar-sub-header level5"><a href="/blog/pages/53eff0/#_3-将任何一个类型断言为-any" class="sidebar-link">3）将任何一个类型断言为 any</a></li><li class="sidebar-sub-header level5"><a href="/blog/pages/53eff0/#_4-将-any-断言为一个具体的类型" class="sidebar-link">4）将 any 断言为一个具体的类型</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_3-类型断言的限制" class="sidebar-link">3.类型断言的限制</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_4-双重断言" class="sidebar-link">4.双重断言</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_5-类型断言-vs-类型转换" class="sidebar-link">5.类型断言 vs 类型转换</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_6-类型断言-vs-类型声明" class="sidebar-link">6.类型断言 vs 类型声明</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_7-类型断言-vs-泛型" class="sidebar-link">7.类型断言 vs 泛型</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/53eff0/#声明文件" class="sidebar-link">声明文件</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_1-新语法" class="sidebar-link">1.新语法</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_2-什么是声明语句" class="sidebar-link">2.什么是声明语句</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_3-什么是声明文件" class="sidebar-link">3.什么是声明文件</a></li><li class="sidebar-sub-header level5"><a href="/blog/pages/53eff0/#_1-第三方声明文件" class="sidebar-link">1）第三方声明文件</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_4-书写声明文件" class="sidebar-link">4.书写声明文件</a></li><li class="sidebar-sub-header level5"><a href="/blog/pages/53eff0/#_1-全局变量" class="sidebar-link">1）全局变量</a></li><li class="sidebar-sub-header level6"><a href="/blog/pages/53eff0/#declare-var" class="sidebar-link">declare var</a></li><li class="sidebar-sub-header level6"><a href="/blog/pages/53eff0/#declare-function" class="sidebar-link">declare function</a></li><li class="sidebar-sub-header level6"><a href="/blog/pages/53eff0/#declare-class" class="sidebar-link">declare class</a></li><li class="sidebar-sub-header level6"><a href="/blog/pages/53eff0/#declare-enum" class="sidebar-link">declare enum</a></li><li class="sidebar-sub-header level6"><a href="/blog/pages/53eff0/#declare-namespace" class="sidebar-link">declare namespace</a></li><li class="sidebar-sub-header level6"><a href="/blog/pages/53eff0/#嵌套的命名空间" class="sidebar-link">嵌套的命名空间</a></li><li class="sidebar-sub-header level6"><a href="/blog/pages/53eff0/#interface-和-type" class="sidebar-link">interface 和 type</a></li><li class="sidebar-sub-header level6"><a href="/blog/pages/53eff0/#防止命名冲突" class="sidebar-link">防止命名冲突</a></li><li class="sidebar-sub-header level5"><a href="/blog/pages/53eff0/#_2-npm-包" class="sidebar-link">2）npm 包</a></li><li class="sidebar-sub-header level6"><a href="/blog/pages/53eff0/#export" class="sidebar-link">export</a></li><li class="sidebar-sub-header level6"><a href="/blog/pages/53eff0/#混用-declare-和-export" class="sidebar-link">混用 declare 和 export</a></li><li class="sidebar-sub-header level6"><a href="/blog/pages/53eff0/#export-namespace" class="sidebar-link">export namespace</a></li><li class="sidebar-sub-header level6"><a href="/blog/pages/53eff0/#export-default" class="sidebar-link">export default</a></li><li class="sidebar-sub-header level6"><a href="/blog/pages/53eff0/#export-2" class="sidebar-link">export =</a></li><li class="sidebar-sub-header level5"><a href="/blog/pages/53eff0/#_3-umd-库" class="sidebar-link">3）UMD 库</a></li><li class="sidebar-sub-header level5"><a href="/blog/pages/53eff0/#_4-直接扩展全局变量" class="sidebar-link">4）直接扩展全局变量</a></li><li class="sidebar-sub-header level5"><a href="/blog/pages/53eff0/#_5-在-npm-包或-umd-库中扩展全局变量" class="sidebar-link">5）在 npm 包或 UMD 库中扩展全局变量</a></li><li class="sidebar-sub-header level5"><a href="/blog/pages/53eff0/#_6-模块插件" class="sidebar-link">6）模块插件</a></li><li class="sidebar-sub-header level5"><a href="/blog/pages/53eff0/#_7-声明文件中的依赖" class="sidebar-link">7）声明文件中的依赖</a></li><li class="sidebar-sub-header level6"><a href="/blog/pages/53eff0/#三斜线指令" class="sidebar-link">三斜线指令</a></li><li class="sidebar-sub-header level5"><a href="/blog/pages/53eff0/#_8-自动生成声明文件" class="sidebar-link">8）自动生成声明文件</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_5-发布声明文件" class="sidebar-link">5.发布声明文件</a></li><li class="sidebar-sub-header level5"><a href="/blog/pages/53eff0/#_1-将声明文件和源码放在一起" class="sidebar-link">1）将声明文件和源码放在一起</a></li><li class="sidebar-sub-header level3"><a href="/blog/pages/53eff0/#_6-内置对象" class="sidebar-link">6.内置对象</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_1-ecmascript-的内置对象" class="sidebar-link">1）ECMAScript 的内置对象</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_2-dom-和-bom-的内置对象" class="sidebar-link">2）DOM 和 BOM 的内置对象</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_3-typescript-核心库的定义文件" class="sidebar-link">3）TypeScript 核心库的定义文件</a></li><li class="sidebar-sub-header level4"><a href="/blog/pages/53eff0/#_4-用-typescript-写-node-js" class="sidebar-link">4）用 TypeScript 写 Node.js</a></li></ul></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper bg-style-6"><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><!----> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/Alan0827" target="_blank" title="作者" class="beLink" data-v-06225672>Alan0827</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2023-03-10</a></div> <div title="分类" class="date iconfont icon-wenjian" data-v-06225672><a href="/blog/categories/?category=%E9%9A%8F%E7%AC%94" data-v-06225672>随笔 </a></div></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">typescript基本使用<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h1 id="typescript-基本使用"><a href="#typescript-基本使用" class="header-anchor">#</a> TypeScript 基本使用</h1> <p>我们知道，JavaScript 是一门非常灵活的编程语言：</p> <ul><li>它没有类型约束，一个变量可能初始化时是字符串，过一会儿又被赋值为数字。</li> <li>由于隐式类型转换的存在，有的变量的类型很难在运行前就确定。</li> <li>基于原型的面向对象编程，使得原型上的属性或方法可以在运行时被修改。</li> <li>函数是 JavaScript 中的一等公民，可以赋值给变量，也可以当作参数或返回值。</li></ul> <p>优点：灵活
缺点：代码质量参差不齐，维护成本高，运行时错误多。</p> <h2 id="typescript-特性"><a href="#typescript-特性" class="header-anchor">#</a> TypeScript 特性</h2> <p><strong>【类型】是其最核心的特性</strong></p> <h3 id="typescript是静态类型"><a href="#typescript是静态类型" class="header-anchor">#</a> TypeScript是静态类型</h3> <p>静态类型是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误。TypeScript 在运行前需要先编译为 JavaScript，而在编译阶段就会进行类型检查</p> <p>这段 TypeScript 代码在编译阶段就会报错了：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Property 'split' does not exist on type 'number'.</span>
<span class="token comment">// 编译时会报错（数字没有 split 方法），无法通过编译</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这段 TypeScript 代码看上去和 JavaScript 没有什么区别,益于 TypeScript 强大的【类型推论】,即使不去手动声明变量 foo 的类型，也能在变量初始化时自动推论出它是一个 number 类型。</p> <p>ts代码</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">let</span> foo<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Property 'split' does not exist on type 'number'.</span>
<span class="token comment">// 编译时会报错（数字没有 split 方法），无法通过编译</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="typescript是弱类型"><a href="#typescript是弱类型" class="header-anchor">#</a> TypeScript是弱类型</h3> <p>类型系统按照「是否允许隐式类型转换」来分类，可以分为强类型和弱类型。JavaScript也是弱类型。TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 打印出字符串 '11'</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>这样的类型系统体现了 TypeScript 的核心设计理念：在完整保留 JavaScript 运行时行为的基础上，通过引入静态类型系统来提高代码的可维护性，减少可能出现的 bug。</p> <h3 id="适用于任何规模"><a href="#适用于任何规模" class="header-anchor">#</a> 适用于任何规模</h3> <p>TypeScript 非常适用于大型项目——这是显而易见的，类型系统可以为大型项目带来更高的可维护性，以及更少的 bug。</p> <p>在中小型项目中推行 TypeScript 的最大障碍就是认为使用 TypeScript 需要写额外的代码，降低开发效率。但事实上，由于有【类型推论】，大部分类型都不需要手动声明了。相反，TypeScript 增强了编辑器（IDE）的功能，包括代码补全、接口提示、跳转到定义、代码重构等，这在很大程度上提高了开发效率。而且 TypeScript 有近百个【编译选项】，如果你认为类型检查过于严格，那么可以通过修改编译选项来降低类型检查的标准。</p> <p>TypeScript 还可以和 JavaScript 共存。这意味着如果你有一个使用 JavaScript 开发的旧项目，又想使用 TypeScript 的特性，那么你不需要急着把整个项目都迁移到 TypeScript，你可以使用 TypeScript 编写新文件，然后在后续更迭中逐步迁移旧文件。如果一些 JavaScript 文件的迁移成本太高，TypeScript 也提供了一个方案，可以让你在不修改 JavaScript 文件的前提下，编写一个【类型声明文件】，实现旧项目的渐进式迁移。</p> <h3 id="与标准同步发展"><a href="#与标准同步发展" class="header-anchor">#</a> 与标准同步发展</h3> <p>TypeScript 的另一个重要的特性就是坚持与 ECMAScript 标准同步发展。</p> <p><strong>什么是 TypeScript？</strong></p> <ul><li>TypeScript 是添加了类型系统的 JavaScript，适用于任何规模的项目。</li> <li>TypeScript 是一门静态类型、弱类型的语言。</li> <li>TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性。</li> <li>TypeScript 可以编译为 JavaScript，然后运行在浏览器、Node.js 等任何能运行 JavaScript 的环境中。</li> <li>TypeScript 拥有很多编译选项，类型检查的严格程度由你决定。</li> <li>TypeScript 可以和 JavaScript 共存，这意味着 JavaScript 项目能够渐进式的迁移到 TypeScript。</li> <li>TypeScript 增强了编辑器（IDE）的功能，提供了代码补全、接口提示、跳转到定义、代码重构等能力。</li> <li>TypeScript 拥有活跃的社区，大多数常用的第三方库都提供了类型声明。</li> <li>TypeScript 与标准同步发展，符合最新的 ECMAScript 标准（stage 3）。</li></ul> <hr> <h2 id="安装typescript"><a href="#安装typescript" class="header-anchor">#</a> 安装TypeScript</h2> <div class="language- line-numbers-mode"><pre class="language-text"><code>npm install -g typescript
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>以上命令会在全局环境下安装 tsc 命令，安装完成之后，我们就可以在任何地方执行 tsc 命令了。</p> <p>编译一个 TypeScript 文件很简单：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>tsc hello.ts
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>我们约定使用 TypeScript 编写的文件以 .ts 为后缀，用 TypeScript 编写 React 时，以 .tsx 为后缀。</p> <h2 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h2> <h3 id="原始数据类型"><a href="#原始数据类型" class="header-anchor">#</a> 原始数据类型</h3> <p>JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。</p> <p>原始数据类型包括：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。</p> <h4 id="_1-布尔值"><a href="#_1-布尔值" class="header-anchor">#</a> 1.布尔值</h4> <p>布尔值是最基础的数据类型，在 TypeScript 中，使用 <strong>boolean</strong>  定义布尔值类型：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let isDone: boolean = false;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意，使用构造函数 Boolean 创造的对象 <strong>不是</strong> 布尔值：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let createdByNewBoolean: boolean = new Boolean(1);

// Type 'Boolean' is not assignable to type 'boolean'.
//   'boolean' is a primitive, but 'Boolean' is a wrapper object. Prefer using 'boolean' when possible.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>事实上 new Boolean() 返回的是一个 Boolean 对象：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let createdByNewBoolean: Boolean = new Boolean(1);  //Boolean 对象
let createdByBoolean: boolean = Boolean(1);   // boolean 类型
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样</p> <h4 id="_2-数值"><a href="#_2-数值" class="header-anchor">#</a> 2.数值</h4> <p>使用 <strong>number</strong>  定义数值类型：</p> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>let decLiteral: number = 6;
let hexLiteral: number = 0xf00d;
// ES6 中的二进制表示法
let binaryLiteral: number = 0b1010;
// ES6 中的八进制表示法
let octalLiteral: number = 0o744;
let notANumber: number = NaN;
let infinityNumber: number = Infinity;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>其中 0b1010 和 0o744 是 ES6 中的二进制和八进制表示法，它们会被编译为十进制数字。</p> <h4 id="_3-字符串"><a href="#_3-字符串" class="header-anchor">#</a> 3.字符串</h4> <p>使用 <strong>string</strong> 定义字符串类型：</p> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>let myName: string = 'Tom';
let myAge: number = 25;

// 模板字符串
let sentence: string = `Hello, my name is ${myName}.
I'll be ${myAge + 1} years old next month.`;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="_4-空值"><a href="#_4-空值" class="header-anchor">#</a> 4.空值</h4> <p>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：</p> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>function alertName(): void {
    alert('My name is Tom');
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null（只在 --strictNullChecks 未指定时）：</p> <h4 id="_5-null-和-undefined"><a href="#_5-null-和-undefined" class="header-anchor">#</a> 5.Null 和 Undefined</h4> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>let u: undefined = undefined;
let n: null = null;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：</p> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>// 这样不会报错
let num: number = undefined;

// 这样也不会报错
let u: undefined;
let num: number = u;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>而 void 类型的变量不能赋值给 number 类型的变量：</p> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>let u: void;
let num: number = u;

// Type 'void' is not assignable to type 'number'.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="任意值"><a href="#任意值" class="header-anchor">#</a> 任意值</h3> <p>任意值（Any）用来表示允许赋值为任意类型。</p> <p>如果是一个普通类型，在赋值过程中改变类型是不被允许的：
但如果是 <strong>any</strong> 类型，则允许被赋值为任意类型。</p> <p>可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。</p> <p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：</p> <h3 id="类型推论"><a href="#类型推论" class="header-anchor">#</a> 类型推论</h3> <p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</p> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>let myFavoriteNumber = 'seven';
myFavoriteNumber = 7;

// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'.


let myFavoriteNumber: string = 'seven';
myFavoriteNumber = 7;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：</strong></p> <h3 id="联合类型"><a href="#联合类型" class="header-anchor">#</a> 联合类型</h3> <p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
myFavoriteNumber = 7;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>联合类型使用 | 分隔每个类型。</p> <p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：</p> <p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型：</p> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>let myFavoriteNumber: string | number;
myFavoriteNumber = 'seven';
console.log(myFavoriteNumber.length); // 5
myFavoriteNumber = 7;
console.log(myFavoriteNumber.length); // 编译时报错

// index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="对象的类型-接口"><a href="#对象的类型-接口" class="header-anchor">#</a> 对象的类型——接口</h3> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>interface Person {
    name: string;
    age: number;
}

let tom: Person = {
    name: 'Tom',
    age: 25
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>注意：<strong>赋值的时候，变量的形状必须和接口的形状保持一致。</strong></p> <h4 id="_1-可选属性"><a href="#_1-可选属性" class="header-anchor">#</a> 1.可选属性</h4> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>interface Person {
    name: string;
    age?: number;
}

let tom: Person = {
    name: 'Tom'
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>这时仍然不允许添加未定义的属性：</p> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>interface Person {
    name: string;
    age?: number;
}

let tom: Person = {
    name: 'Tom',
    age: 25,
    gender: 'male'
};

// examples/playground/index.ts(9,5): error TS2322: Type '{ name: string; age: number; gender: string; }' is not assignable to type 'Person'.
//   Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="_2-任意属性"><a href="#_2-任意属性" class="header-anchor">#</a> 2.任意属性</h4> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>interface Person {
    name: string;
    age?: number;
    [propName: string]: any;
}

let tom: Person = {
    name: 'Tom',
    gender: 'male'
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><blockquote><p>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集
一个接口中只能定义一个任意属性 可以使用联合属性</p></blockquote> <h4 id="_3-只读属性"><a href="#_3-只读属性" class="header-anchor">#</a> 3.只读属性</h4> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>interface Person {
    readonly id: number;
    name: string;
    age?: number;
    [propName: string]: any;
}

let tom: Person = {
    id: 89757,
    name: 'Tom',
    gender: 'male'
};

tom.id = 9527;

// index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：</p> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>interface Person {
    readonly id: number;
    name: string;
    age?: number;
    [propName: string]: any;
}

let tom: Person = {
    name: 'Tom',
    gender: 'male'
};

tom.id = 89757;

// index.ts(8,5): error TS2322: Type '{ name: string; gender: string; }' is not assignable to type 'Person'.
//   Property 'id' is missing in type '{ name: string; gender: string; }'.
// index.ts(13,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>上例中，报错信息有两处，第一处是在对 tom 进行赋值的时候，没有给 id 赋值。</p> <p>第二处是在给 tom.id 赋值的时候，由于它是只读属性，所以报错了。</p> <h3 id="数组的类型"><a href="#数组的类型" class="header-anchor">#</a> 数组的类型</h3> <p>在 TypeScript 中，数组类型有多种定义方式，比较灵活。</p> <h4 id="_1-类型-方括号"><a href="#_1-类型-方括号" class="header-anchor">#</a> 1.类型 + 方括号</h4> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>let fibonacci: number[] = [1, 1, 2, 3, 5];

//数组的项中不允许出现其他的类型：
let fibonacci: number[] = [1, '1', 2, 3, 5];

// Type 'string' is not assignable to type 'number'.

// 数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：
let fibonacci: number[] = [1, 1, 2, 3, 5];
fibonacci.push('8');

// Argument of type '&quot;8&quot;' is not assignable to parameter of type 'number'.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="_2-数组泛型"><a href="#_2-数组泛型" class="header-anchor">#</a> 2.数组泛型</h4> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="_3-用接口表示数组"><a href="#_3-用接口表示数组" class="header-anchor">#</a> 3.用接口表示数组</h4> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>interface NumberArray {
    [index: number]: number;
}
let fibonacci: NumberArray = [1, 1, 2, 3, 5];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>NumberArray 表示：只要索引的类型是数字时，那么值的类型必须是数字。
虽然接口也可以用来描述数组，但是我们一般不会这么做，因为这种方式比前两种方式复杂多了。
不过有一种情况例外，那就是它常用来表示类数组</p> <h4 id="_4-类数组"><a href="#_4-类数组" class="header-anchor">#</a> 4.类数组</h4> <p>类数组（Array-like Object）不是数组类型，比如 arguments</p> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>function sum() {
    let args: number[] = arguments;
}

// Type 'IArguments' is missing the following properties from type 'number[]': pop, push, concat, join, and 24 more.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上例中，arguments 实际上是一个类数组，不能用普通的数组的方式来描述，而应该用接口：</p> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>function sum() {
    let args: {
        [index: number]: number;
        length: number;
        callee: Function;
    } = arguments;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>在这个例子中，我们除了约束当索引的类型是数字时，值的类型必须是数字之外，也约束了它还有 length 和 callee 两个属性。</p> <p>事实上常用的类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection 等：</p> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>function sum() {
    let args: IArguments = arguments;
}


//其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：
interface IArguments {
    [index: number]: any;
    length: number;
    callee: Function;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h4 id="_5-any-在数组中的应用"><a href="#_5-any-在数组中的应用" class="header-anchor">#</a> 5.any 在数组中的应用</h4> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>let list: any[] = ['xcatliu', 25, { website: 'http://xcatliu.com' }];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="函数的类型"><a href="#函数的类型" class="header-anchor">#</a> 函数的类型</h3> <h4 id="_1-函数声明"><a href="#_1-函数声明" class="header-anchor">#</a> 1.函数声明</h4> <p>在 JavaScript 中，有两种常见的定义函数的方式——函数声明（Function Declaration）和函数表达式（Function Expression）：</p> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>// 函数声明（Function Declaration）
function sum(x, y) {
    return x + y;
}

// 函数表达式（Function Expression）
let mySum = function (x, y) {
    return x + y;
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>一个函数有输入和输出，要在 TypeScript 中对其进行约束</p> <div class="language-lang line-numbers-mode"><pre class="language-text"><code>function sum(x: number, y: number): number {
    return x + y;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>注意，输入多余的（或者少于要求的）参数，是不被允许的</p> <h4 id="_2-函数表达式"><a href="#_2-函数表达式" class="header-anchor">#</a> 2.函数表达式</h4> <p>如果要我们现在写一个对函数表达式（Function Expression）的定义，可能会写成这样：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let mySum = function (x: number, y: number): number {
    return x + y;
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 mySum，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 mySum 添加类型，则应该是这样：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number {
    return x + y;
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>注意不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;。</p> <p>在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p> <h4 id="_3-用接口定义函数的形状"><a href="#_3-用接口定义函数的形状" class="header-anchor">#</a> 3.用接口定义函数的形状</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface SearchFunc {
    (source: string, subString: string): boolean;
}

let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
    return source.search(subString) !== -1;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>采用函数表达式、接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变</p> <h4 id="_4-可选参数"><a href="#_4-可选参数" class="header-anchor">#</a> 4.可选参数</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>function buildName(firstName: string, lastName?: string) {
    if (lastName) {
        return firstName + ' ' + lastName;
    } else {
        return firstName;
    }
}   
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>注意，可选参数后面不允许再出现必需参数了</p> <h4 id="_5-参数默认值"><a href="#_5-参数默认值" class="header-anchor">#</a> 5.参数默认值</h4> <p>在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function buildName(firstName: string, lastName: string = 'Cat') {
    return firstName + ' ' + lastName;
}
let tomcat = buildName('Tom', 'Cat');
let tom = buildName('Tom');


//此时就不受「可选参数必须接在必需参数后面」的限制了
function buildName(firstName: string = 'Tom', lastName: string) {
    return firstName + ' ' + lastName;
}
let tomcat = buildName('Tom', 'Cat');
let cat = buildName(undefined, 'Cat');
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="_6-剩余参数"><a href="#_6-剩余参数" class="header-anchor">#</a> 6.剩余参数</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>function push(array: any[], ...items: any[]) {
    items.forEach(function(item) {
        array.push(item);
    });
}

let a = [];
push(a, 1, 2, 3);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>事实上，items 是一个数组。所以我们可以用数组的类型来定义它：</p> <h4 id="_7-重载"><a href="#_7-重载" class="header-anchor">#</a> 7.重载</h4> <p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理
利用联合类型，我们可以这么实现</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function reverse(x: number | string): number | string | void {
    if (typeof x === 'number') {
        return Number(x.toString().split('').reverse().join(''));
    } else if (typeof x === 'string') {
        return x.split('').reverse().join('');
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。
我们可以使用重载定义多个 reverse 的函数类型：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function reverse(x: number): number;
function reverse(x: string): string;
function reverse(x: number | string): number | string | void {
    if (typeof x === 'number') {
        return Number(x.toString().split('').reverse().join(''));
    } else if (typeof x === 'string') {
        return x.split('').reverse().join('');
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</p> <p>注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p> <h3 id="类型断言"><a href="#类型断言" class="header-anchor">#</a> 类型断言</h3> <p>类型断言（Type Assertion）可以用来手动指定一个值的类型。</p> <h4 id="_1-语法"><a href="#_1-语法" class="header-anchor">#</a> 1.语法</h4> <div class="language-js line-numbers-mode"><pre class="language-js"><code>值 <span class="token keyword">as</span> 类型
或
<span class="token operator">&lt;</span>类型<span class="token operator">&gt;</span>值
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在 tsx 语法（React 的 jsx 语法的 ts 版）中必须使用前者，即 值 as 类型。
形如 《Foo》 的语法在 tsx 中表示的是一个 ReactNode，在 ts 中除了表示类型断言之外，也可能是表示一个泛型。
故建议大家在使用类型断言时，统一使用 值 as 类型 这样的语法</p> <h4 id="_2-类型断言的用途"><a href="#_2-类型断言的用途" class="header-anchor">#</a> 2.类型断言的用途</h4> <h5 id="_1-将一个联合类型断言为其中一个类型"><a href="#_1-将一个联合类型断言为其中一个类型" class="header-anchor">#</a> 1）将一个联合类型断言为其中一个类型</h5> <p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型中共有的属性或方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Cat {
    name: string;
    run(): void;
}
interface Fish {
    name: string;
    swim(): void;
}

function getName(animal: Cat | Fish) {
    return animal.name;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型特有的属性或方法，比如：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Cat {
    name: string;
    run(): void;
}
interface Fish {
    name: string;
    swim(): void;
}

function isFish(animal: Cat | Fish) {
    if (typeof animal.swim === 'function') {
        return true;
    }
    return false;
}

// index.ts:11:23 - error TS2339: Property 'swim' does not exist on type 'Cat | Fish'.
//   Property 'swim' does not exist on type 'Cat'.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>上面的例子中，获取 animal.swim 的时候会报错。</p> <p>此时可以使用类型断言，将 animal 断言成 Fish：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Cat {
    name: string;
    run(): void;
}
interface Fish {
    name: string;
    swim(): void;
}

function isFish(animal: Cat | Fish) {
    if (typeof (animal as Fish).swim === 'function') {
        return true;
    }
    return false;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>需要注意的是，类型断言只能够「欺骗」TypeScript 编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Cat {
    name: string;
    run(): void;
}
interface Fish {
    name: string;
    swim(): void;
}

function swim(animal: Cat | Fish) {
    (animal as Fish).swim();
}

const tom: Cat = {
    name: 'Tom',
    run() { console.log('run') }
};
swim(tom);
// Uncaught TypeError: animal.swim is not a function`
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>原因是 (animal as Fish).swim() 这段代码隐藏了 animal 可能为 Cat 的情况，将 animal 直接断言为 Fish 了，而 TypeScript 编译器信任了我们的断言，故在调用 swim() 时没有编译错误。</p> <p>可是 swim 函数接受的参数是 Cat | Fish，一旦传入的参数是 Cat 类型的变量，由于 Cat 上没有 swim 方法，就会导致运行时错误了。</p> <p>总之，使用类型断言时一定要格外小心，尽量避免断言后调用方法或引用深层属性，以减少不必要的运行时错误。</p> <hr> <h5 id="_2-将一个父类断言为更加具体的子类"><a href="#_2-将一个父类断言为更加具体的子类" class="header-anchor">#</a> 2）将一个父类断言为更加具体的子类</h5> <p>当类之间有继承关系时，类型断言也是很常见的：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class ApiError extends Error {
    code: number = 0;
}
class HttpError extends Error {
    statusCode: number = 200;
}

function isApiError(error: Error) {
    if (typeof (error as ApiError).code === 'number') {
        return true;
    }
    return false;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>由于父类 Error 中没有 code 属性，故直接获取 error.code 会报错，需要使用类型断言获取 (error as ApiError).code。</p> <p>在这个例子中有一个更合适的方式来判断是不是 ApiError，那就是使用 instanceof：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>class ApiError extends Error {
    code: number = 0;
}
class HttpError extends Error {
    statusCode: number = 200;
}
function isApiError(error: Error) {
    if (error instanceof ApiError) {
        return true;
    }
    return false;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>上面的例子中，确实使用 instanceof 更加合适，因为 ApiError 是一个 JavaScript 的类，能够通过 instanceof 来判断 error 是否是它的实例</p> <p>但是有的情况下 ApiError 和 HttpError 不是一个真正的类，而只是一个 TypeScript 的接口（interface），接口是一个类型，不是一个真正的值，它在编译结果中会被删除，当然就无法使用 instanceof 来做运行时判断了：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface ApiError extends Error {
    code: number;
}
interface HttpError extends Error {
    statusCode: number;
}

function isApiError(error: Error) {
    if (error instanceof ApiError) {
        return true;
    }
    return false;
}

// index.ts:9:26 - error TS2693: 'ApiError' only refers to a type, but is being used as a value here.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>此时就只能用类型断言，通过判断是否存在 code 属性，来判断传入的参数是不是 ApiError 了：</p> <h5 id="_3-将任何一个类型断言为-any"><a href="#_3-将任何一个类型断言为-any" class="header-anchor">#</a> 3）将任何一个类型断言为 any</h5> <p>理想情况下，TypeScript 的类型系统运转良好，每个值的类型都具体而精确。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>window.foo = 1;

// index.ts:1:8 - error TS2339: Property 'foo' does not exist on type 'Window &amp; typeof globalThis'.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面的例子中，我们需要将 window 上添加一个属性 foo，但 TypeScript 编译时会报错，提示我们 window 上不存在 foo 属性。</p> <p>此时我们可以使用 as any 临时将 window 断言为 any 类型：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>(window as any).foo = 1;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>需要注意的是，将一个变量断言为 any 可以说是解决 TypeScript 中类型问题的最后一个手段。</p> <p><em>它极有可能掩盖了真正的类型错误，所以如果不是非常确定，就不要使用 as any。</em>
总之，一方面不能滥用 as any，另一方面也不要完全否定它的作用，我们需要在类型的严格性和开发的便利性之间掌握平衡（这也是 TypeScript 的设计理念之一），才能发挥出 TypeScript 最大的价值。</p> <h5 id="_4-将-any-断言为一个具体的类型"><a href="#_4-将-any-断言为一个具体的类型" class="header-anchor">#</a> 4）将 any 断言为一个具体的类型</h5> <p>举例来说，历史遗留的代码中有个 getCacheData，它的返回值是 any：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function getCacheData(key: string): any {
    return (window as any).cache[key];
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>那么我们在使用它时，最好能够将调用了它之后的返回值断言成一个精确的类型，这样就方便了后续的操作</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function getCacheData(key: string): any {
    return (window as any).cache[key];
}

interface Cat {
    name: string;
    run(): void;
}

const tom = getCacheData('tom') as Cat;
tom.run();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>上面的例子中，我们调用完 getCacheData 之后，立即将它断言为 Cat 类型。这样的话明确了 tom 的类型，后续对 tom 的访问时就有了代码补全，提高了代码的可维护性。</p> <h4 id="_3-类型断言的限制"><a href="#_3-类型断言的限制" class="header-anchor">#</a> 3.类型断言的限制</h4> <p>并不是任何一个类型都可以被断言为任何另一个类型
具体来说，若 A 兼容 B，那么 A 能够被断言为 B，B 也能被断言为 A。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Animal {
    name: string;
}
interface Cat {
    name: string;
    run(): void;
}

let tom: Cat = {
    name: 'Tom',
    run: () =&gt; { console.log('run') }
};
let animal: Animal = tom;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>TypeScript 是结构类型系统，类型之间的对比只会比较它们最终的结构，而会忽略它们定义时的关系。</p> <p>在上面的例子中，Cat 包含了 Animal 中的所有属性，除此之外，它还有一个额外的方法 run。TypeScript 并不关心 Cat 和 Animal 之间定义时是什么关系，而只会看它们最终的结构有什么关系——所以它与 Cat extends Animal 是等价的：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Animal {
    name: string;
}
interface Cat extends Animal {
    run(): void;
}

function testAnimal(animal: Animal) {
    return (animal as Cat);
}
function testCat(cat: Cat) {
    return (cat as Animal);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ul><li>父类可以被断言为子类</li> <li>子类可以被断言为父类</li></ul> <h4 id="_4-双重断言"><a href="#_4-双重断言" class="header-anchor">#</a> 4.双重断言</h4> <ul><li>任何类型都可以被断言为 any</li> <li>any 可以被断言为任何类型</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Cat {
    run(): void;
}
interface Fish {
    swim(): void;
}

function testCat(cat: Cat) {
    return (cat as any as Fish);
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>使用双重断言，则可以打破「要使得 A 能够被断言为 B，只需要 A 兼容 B 或 B 兼容 A 即可」的限制，将任何一个类型断言为任何另一个类型。</p> <p><em>除非迫不得已，千万别用双重断言</em></p> <h4 id="_5-类型断言-vs-类型转换"><a href="#_5-类型断言-vs-类型转换" class="header-anchor">#</a> 5.类型断言 vs 类型转换</h4> <p>类型断言只会影响 TypeScript 编译时的类型，类型断言语句在编译结果中会被删除</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function toBoolean(something: any): boolean {
    return something as boolean;
}

toBoolean(1);
// 返回值为 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在上面的例子中，将 something 断言为 boolean 虽然可以通过编译，但是并没有什么用，代码在编译后会变成：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function toBoolean(something) {
    return something;
}

toBoolean(1);
// 返回值为 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>所以类型断言不是类型转换，它不会真的影响到变量的类型。</p> <p>若要进行类型转换，需要直接调用类型转换的方法：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function toBoolean(something: any): boolean {
    return Boolean(something);
}

toBoolean(1);
// 返回值为 true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="_6-类型断言-vs-类型声明"><a href="#_6-类型断言-vs-类型声明" class="header-anchor">#</a> 6.类型断言 vs 类型声明</h4> <p>断言</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function getCacheData(key: string): any {
    return (window as any).cache[key];
}

interface Cat {
    name: string;
    run(): void;
}

const tom = getCacheData('tom') as Cat;
tom.run();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>和</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function getCacheData(key: string): any {
    return (window as any).cache[key];
}

interface Cat {
    name: string;
    run(): void;
}

const tom: Cat = getCacheData('tom');
tom.run();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>这和类型断言是非常相似的，而且产生的结果也几乎是一样的——tom 在接下来的代码中都变成了 Cat 类型。</p> <p>区别</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Animal {
    name: string;
}
interface Cat {
    name: string;
    run(): void;
}

const animal: Animal = {
    name: 'tom'
};
let tom = animal as Cat;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>在上面的例子中，由于 Animal 兼容 Cat，故可以将 animal 断言为 Cat 赋值给 tom。</p> <p>但是若直接声明 tom 为 Cat 类型：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Animal {
    name: string;
}
interface Cat {
    name: string;
    run(): void;
}

const animal: Animal = {
    name: 'tom'
};
let tom: Cat = animal;

// index.ts:12:5 - error TS2741: Property 'run' is missing in type 'Animal' but required in type 'Cat'.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>则会报错，不允许将 animal 赋值为 Cat 类型的 tom。</p> <p>这很容易理解，Animal 可以看作是 Cat 的父类，当然不能将父类的实例赋值给类型为子类的变量。</p> <ul><li>animal 断言为 Cat，只需要满足 Animal 兼容 Cat 或 Cat 兼容 Animal 即可</li> <li>animal 赋值给 tom，需要满足 Cat 兼容 Animal 才行</li></ul> <p>类型声明是比类型断言更加严格
所以为了增加代码的质量，我们最好优先使用类型声明，这也比类型断言的 as 语法更加优雅。</p> <h4 id="_7-类型断言-vs-泛型"><a href="#_7-类型断言-vs-泛型" class="header-anchor">#</a> 7.类型断言 vs 泛型</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>function getCacheData(key: string): any {
    return (window as any).cache[key];
}

interface Cat {
    name: string;
    run(): void;
}

const tom = getCacheData('tom') as Cat;
tom.run();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div class="language- line-numbers-mode"><pre class="language-text"><code>function getCacheData&lt;T&gt;(key: string): T {
    return (window as any).cache[key];
}

interface Cat {
    name: string;
    run(): void;
}

const tom = getCacheData&lt;Cat&gt;('tom');
tom.run();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>通过给 getCacheData 函数添加了一个泛型，我们可以更加规范的实现对 getCacheData 返回值的约束，这也同时去除掉了代码中的 any，是最优的一个解决方案。</p> <h3 id="声明文件"><a href="#声明文件" class="header-anchor">#</a> 声明文件</h3> <p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p> <h4 id="_1-新语法"><a href="#_1-新语法" class="header-anchor">#</a> 1.新语法</h4> <ul><li>declare var 声明全局变量</li> <li>declare function 声明全局方法</li> <li>declare class 声明全局类</li> <li>declare enum 声明全局枚举类型</li> <li>declare namespace 声明（含有子属性的）全局对象</li> <li>interface 和 type 声明全局类型</li> <li>export 导出变量</li> <li>export namespace 导出（含有子属性的）对象</li> <li>export default ES6 默认导出</li> <li>export = commonjs 导出模块</li> <li>export as namespace UMD 库声明全局变量</li> <li>declare global 扩展全局变量</li> <li>declare module 扩展模块</li> <li>/// <reference></reference> 三斜线指令</li></ul> <h4 id="_2-什么是声明语句"><a href="#_2-什么是声明语句" class="header-anchor">#</a> 2.什么是声明语句</h4> <div class="language- line-numbers-mode"><pre class="language-text"><code>$('#foo');
// or
jQuery('#foo');
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>但是在 ts 中，编译器并不知道 $ 或 jQuery 是什么东西：</p> <p>这时，我们需要使用 declare var 来定义它的类型</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>declare var jQuery: (selector: string) =&gt; any;

jQuery('#foo');
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上例中，declare var 并没有真的定义一个变量，只是定义了全局变量 jQuery 的类型，仅仅会用于编译时的检查，在编译结果中会被删除</p> <h4 id="_3-什么是声明文件"><a href="#_3-什么是声明文件" class="header-anchor">#</a> 3.什么是声明文件</h4> <p>通常我们会把声明语句放到一个单独的文件（jQuery.d.ts）中，这就是声明文件</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src/jQuery.d.ts

declare var jQuery: (selector: string) =&gt; any;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h5 id="_1-第三方声明文件"><a href="#_1-第三方声明文件" class="header-anchor">#</a> 1）第三方声明文件</h5> <p>当然，jQuery 的声明文件不需要我们定义了，社区已经帮我们定义好了：jQuery in DefinitelyTyped。</p> <p>我们可以直接下载下来使用，但是更推荐的是使用 @types 统一管理第三方库的声明文件</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>npm install @types/jquery --save-dev
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>可以在<a href="https://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener noreferrer">这里<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>查找</p> <h4 id="_4-书写声明文件"><a href="#_4-书写声明文件" class="header-anchor">#</a> 4.书写声明文件</h4> <p>真正书写一个声明文件并不是一件简单的事</p> <h5 id="_1-全局变量"><a href="#_1-全局变量" class="header-anchor">#</a> 1）全局变量</h5> <p>全局变量的声明文件主要有以下几种语法</p> <ul><li>declare var 声明全局变量</li> <li>declare function 声明全局方法</li> <li>declare class 声明全局类</li> <li>declare enum 声明全局枚举类型</li> <li>declare namespace 声明（含有子属性的）全局对象</li> <li>interface 和 type 声明全局类型</li></ul> <h6 id="declare-var"><a href="#declare-var" class="header-anchor">#</a> declare var</h6> <div class="language- line-numbers-mode"><pre class="language-text"><code>declare let jQuery: (selector: string) =&gt; any;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>类似的，还有 declare let 和 declare const，使用 let 与使用 var 没有什么区别
一般来说，全局变量都是禁止修改的常量，所以大部分情况都应该使用 const 而不是 var 或 let。</p> <p>需要注意的是，声明语句中只能定义类型，切勿在声明语句中定义具体的实现</p> <h6 id="declare-function"><a href="#declare-function" class="header-anchor">#</a> declare function</h6> <p>declare function 用来定义全局函数的类型。jQuery 其实就是一个函数，所以也可以用 function 来定义</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src/jQuery.d.ts

declare function jQuery(selector: string): any;


jQuery('#foo');
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>在函数类型的声明语句中，函数重载也是支持的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src/jQuery.d.ts

declare function jQuery(selector: string): any;
declare function jQuery(domReadyCallback: () =&gt; any): any;


jQuery('#foo');
jQuery(function() {
    alert('1111');
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h6 id="declare-class"><a href="#declare-class" class="header-anchor">#</a> declare class</h6> <p>当全局变量是一个类的时候，我们用 declare class 来定义它的类型</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>declare class Animal {
    name: string;
    constructor(name: string);
    sayHi(): string;
}

let cat = new Animal('Tom');
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>同样的，declare class 语句也只能用来定义类型，不能用来定义具体的实现</p> <h6 id="declare-enum"><a href="#declare-enum" class="header-anchor">#</a> declare enum</h6> <div class="language- line-numbers-mode"><pre class="language-text"><code>declare enum Directions {
    Up,
    Down,
    Left,
    Right
}

let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>与其他全局变量的类型声明一致，declare enum 仅用来定义类型，而不是具体的值。</p> <p>Directions.d.ts 仅仅会用于编译时的检查，声明文件里的内容在编译结果中会被删除</p> <h6 id="declare-namespace"><a href="#declare-namespace" class="header-anchor">#</a> declare namespace</h6> <p>namespace 是 ts 早期时为了解决模块化而创造的关键字，中文称为命名空间</p> <p>随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的 namespace，而推荐使用 ES6 的模块化方案了，故我们不再需要学习 namespace 的使用了。</p> <p>namespace 被淘汰了，但是在声明文件中，declare namespace 还是比较常用的，它用来表示全局变量是一个对象，包含很多子属性。</p> <p>比如 jQuery 是一个全局变量，它是一个对象，提供了一个 jQuery.ajax 方法可以调用，那么我们就应该使用 declare namespace jQuery 来声明这个拥有多个子属性的全局变量。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src/jQuery.d.ts
declare namespace jQuery {
    function ajax(url: string, settings?: any): void;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>注意，在 declare namespace 内部，我们直接使用 function ajax 来声明函数，而不是使用 declare function ajax。类似的，也可以使用 const, class, enum 等语句</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src/jQuery.d.ts
declare namespace jQuery {
    function ajax(url: string, settings?: any): void;
    const version: number;
    class Event {
        blur(eventType: EventType): void
    }
    enum EventType {
        CustomClick
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h6 id="嵌套的命名空间"><a href="#嵌套的命名空间" class="header-anchor">#</a> 嵌套的命名空间</h6> <p>如果对象拥有深层的层级，则需要用嵌套的 namespace 来声明深层的属性的类型</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src/jQuery.d.ts
declare namespace jQuery {
    function ajax(url: string, settings?: any): void;
    namespace fn {
        function extend(object: any): void;
    }
}

// src/index.ts
jQuery.ajax('/api/get_something');
jQuery.fn.extend({
    check: function() {
        return this.each(function() {
            this.checked = true;
        });
    }
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h6 id="interface-和-type"><a href="#interface-和-type" class="header-anchor">#</a> interface 和 type</h6> <p>除了全局变量之外，可能有一些类型我们也希望能暴露出来。在类型声明文件中，我们可以直接使用 interface 或 type 来声明一个全局的接口或类型</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src/jQuery.d.ts

interface AjaxSettings {
    method?: 'GET' | 'POST'
    data?: any;
}
declare namespace jQuery {
    function ajax(url: string, settings?: AjaxSettings): void;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>type 与 interface 类似</p> <h6 id="防止命名冲突"><a href="#防止命名冲突" class="header-anchor">#</a> 防止命名冲突</h6> <p>暴露在最外层的 interface 或 type 会作为全局类型作用于整个项目中，我们应该尽可能的减少全局变量或全局类型的数量。故最好将他们放到 namespace 下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src/jQuery.d.ts

declare namespace jQuery {
    interface AjaxSettings {
        method?: 'GET' | 'POST'
        data?: any;
    }
    function ajax(url: string, settings?: AjaxSettings): void;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在使用这个 interface 的时候，也应该加上 jQuery 前缀</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src/index.ts

let settings: jQuery.AjaxSettings = {
    method: 'POST',
    data: {
        name: 'foo'
    }
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h5 id="_2-npm-包"><a href="#_2-npm-包" class="header-anchor">#</a> 2）npm 包</h5> <p>一般我们通过 import foo from 'foo' 导入一个 npm 包，这是符合 ES6 模块规范的。</p> <p>在我们尝试给一个 npm 包创建声明文件之前，需要先看看它的声明文件是否已经存在。一般来说，npm 包的声明文件可能存在于两个地方：</p> <ol><li>与该 npm 包绑定在一起。判断依据是 package.json 中有 types 字段，或者有一个 index.d.ts 声明文件。这种模式不需要额外安装其他包，是最为推荐的，所以以后我们自己创建 npm 包的时候，最好也将声明文件与 npm 包绑定在一起。</li> <li>发布到 @types 里。我们只需要尝试安装一下对应的 @types 包就知道是否存在该声明文件，安装命令是 npm install @types/foo --save-dev。这种模式一般是由于 npm 包的维护者没有提供声明文件，所以只能由其他人将声明文件发布到 @types 里了。</li></ol> <p>假如以上两种方式都没有找到对应的声明文件，那么我们就需要自己为它写声明文件了。由于是通过 import 语句导入的模块，所以声明文件存放的位置也有所约束，一般有两种方案：</p> <ol><li>创建一个 node_modules/@types/foo/index.d.ts 文件，存放 foo 模块的声明文件。这种方式不需要额外的配置，但是 node_modules 目录不稳定，代码也没有被保存到仓库中，无法回溯版本，有不小心被删除的风险，故不太建议用这种方案，一般只用作临时测试。</li> <li>创建一个 types 目录，专门用来管理自己写的声明文件，将 foo 的声明文件放到 types/foo/index.d.ts 中。这种方式需要配置下 tsconfig.json 中的 paths 和 baseUrl 字段</li></ol> <p>npm 包的声明文件主要有以下几种语法</p> <ul><li>export 导出变量</li> <li>export namespace 导出（含有子属性的）对象</li> <li>export default ES6 默认导出</li> <li>export = commonjs 导出模块</li></ul> <h6 id="export"><a href="#export" class="header-anchor">#</a> export</h6> <p>npm 包的声明文件与全局变量的声明文件有很大区别。在 npm 包的声明文件中，使用 declare 不再会声明一个全局变量，而只会在当前文件中声明一个局部变量。
只有在声明文件中使用 export 导出，然后在使用方 import 导入后，才会应用到这些类型声明</p> <ul><li>export 的语法与普通的 ts 中的语法类似，区别仅在于声明文件中禁止定义具体的实现</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>// types/foo/index.d.ts

export const name: string;
export function getName(): string;
export class Animal {
    constructor(name: string);
    sayHi(): string;
}
export enum Directions {
    Up,
    Down,
    Left,
    Right
}
export interface Options {
    data: any;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>对应的导入和使用模块应该是这样</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// src/index.ts

import { name, getName, Animal, Directions, Options } from 'foo';

console.log(name);
let myName = getName();
let cat = new Animal('Tom');
let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];
let options: Options = {
    data: {
        name: 'foo'
    }
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h6 id="混用-declare-和-export"><a href="#混用-declare-和-export" class="header-anchor">#</a> 混用 declare 和 export</h6> <p>我们也可以使用 declare 先声明多个变量，最后再用 export 一次性导出。上例的声明文件可以等价的改写为</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// types/foo/index.d.ts

declare const name: string;
declare function getName(): string;
declare class Animal {
    constructor(name: string);
    sayHi(): string;
}
declare enum Directions {
    Up,
    Down,
    Left,
    Right
}
interface Options {
    data: any;
}

export { name, getName, Animal, Directions, Options };
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h6 id="export-namespace"><a href="#export-namespace" class="header-anchor">#</a> export namespace</h6> <p>与 declare namespace 类似，export namespace 用来导出一个拥有子属性的对象</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// types/foo/index.d.ts

export namespace foo {
    const name: string;
    namespace bar {
        function baz(): string;
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h6 id="export-default"><a href="#export-default" class="header-anchor">#</a> export default</h6> <p>在 ES6 模块系统中，使用 export default 可以导出一个默认值，使用方可以用 import foo from 'foo' 而不是 import { foo } from 'foo' 来导入这个默认值。</p> <p>在类型声明文件中，export default 用来导出默认值的类型</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// types/foo/index.d.ts

export default function foo(): string;


// src/index.ts

import foo from 'foo';

foo();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>注意，只有 function、class 和 interface 可以直接默认导出，其他的变量需要先定义出来，再默认导出</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// types/foo/index.d.ts

declare enum Directions {
    Up,
    Down,
    Left,
    Right
}
export default Directions;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h6 id="export-2"><a href="#export-2" class="header-anchor">#</a> export =</h6> <p>在 commonjs 规范中，我们用以下方式来导出一个模块：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 整体导出
module.exports = foo;
// 单个导出
exports.bar = bar;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在 ts 中，针对这种模块导出，有多种方式可以导入，第一种方式是 const ... = require：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 整体导入
const foo = require('foo');
// 单个导入
const bar = require('foo').bar;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>第二种方式是 import ... from，注意针对整体导出，需要使用 import * as 来导入</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 整体导入
import * as foo from 'foo';
// 单个导入
import { bar } from 'foo';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>第三种方式是 import ... require，这也是 ts 官方推荐的方式</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 整体导入
import foo = require('foo');
// 单个导入
import bar = foo.bar
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>对于这种使用 commonjs 规范的库，假如要为它写类型声明文件的话，就需要使用到 export = 这种语法</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// types/foo/index.d.ts

export = foo;

declare function foo(): string;
declare namespace foo {
    const bar: number;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>需要注意的是，上例中使用了 export = 之后，就不能再单个导出 export { bar } 了。所以我们通过声明合并，使用 declare namespace foo 来将 bar 合并到 foo 里。</p> <p>准确地讲，export = 不仅可以用在声明文件中，也可以用在普通的 ts 文件中。实际上，import ... require 和 export = 都是 ts 为了兼容 AMD 规范和 commonjs 规范而创立的新语法，由于并不常用也不推荐使用</p> <p>由于很多第三方库是 commonjs 规范的，所以声明文件也就不得不用到 export = 这种语法了。但是还是需要再强调下，相比与 export =，我们更推荐使用 ES6 标准的 export default 和 export。</p> <h5 id="_3-umd-库"><a href="#_3-umd-库" class="header-anchor">#</a> 3）UMD 库</h5> <p>既可以通过 script 标签引入，又可以通过 import 导入的库，称为 UMD 库。相比于 npm 包的类型声明文件，我们需要额外声明一个全局变量，为了实现这种方式，ts 提供了一个新语法 export as namespace</p> <p>一般使用 export as namespace 时，都是先有了 npm 包的声明文件，再基于它添加一条 export as namespace 语句，即可将声明好的一个变量声明为全局变量</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// types/foo/index.d.ts

export as namespace foo;
export = foo;

declare function foo(): string;
declare namespace foo {
    const bar: number;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>当然它也可以与 export default 一起使用</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// types/foo/index.d.ts

export as namespace foo;
export default foo;

declare function foo(): string;
declare namespace foo {
    const bar: number;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h5 id="_4-直接扩展全局变量"><a href="#_4-直接扩展全局变量" class="header-anchor">#</a> 4）直接扩展全局变量</h5> <p>有的第三方库扩展了一个全局变量，可是此全局变量的类型却没有相应的更新过来，就会导致 ts 编译错误，此时就需要扩展全局变量的类型。比如扩展 String 类型</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface String {
    prependHello(): string;
}

'foo'.prependHello();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>通过声明合并，使用 interface String 即可给 String 添加属性或方法。</p> <p>也可以使用 declare namespace 给已有的命名空间添加类型声明</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// types/jquery-plugin/index.d.ts

declare namespace JQuery {
    interface CustomOptions {
        bar: string;
    }
}

interface JQueryStatic {
    foo(options: JQuery.CustomOptions): string;
}


// src/index.ts

jQuery.foo({
    bar: ''
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h5 id="_5-在-npm-包或-umd-库中扩展全局变量"><a href="#_5-在-npm-包或-umd-库中扩展全局变量" class="header-anchor">#</a> 5）在 npm 包或 UMD 库中扩展全局变量</h5> <p>如之前所说，对于一个 npm 包或者 UMD 库的声明文件，只有 export 导出的类型声明才能被导入。所以对于 npm 包或 UMD 库，如果导入此库之后会扩展全局变量，则需要使用另一种语法在声明文件中扩展全局变量的类型，那就是 declare global</p> <p>使用 declare global 可以在 npm 包或者 UMD 库的声明文件中扩展全局变量的类型</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// types/foo/index.d.ts

declare global {
    interface String {
        prependHello(): string;
    }
}

export {};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>注意即使此声明文件不需要导出任何东西，仍然需要导出一个空对象，用来告诉编译器这是一个模块的声明文件，而不是一个全局变量的声明文件</p> <h5 id="_6-模块插件"><a href="#_6-模块插件" class="header-anchor">#</a> 6）模块插件</h5> <p>有时通过 import 导入一个模块插件，可以改变另一个原有模块的结构。此时如果原有模块已经有了类型声明文件，而插件模块没有类型声明文件，就会导致类型不完整，缺少插件部分的类型。ts 提供了一个语法 declare module，它可以用来扩展原有模块的类型。</p> <p>如果是需要扩展原有模块的话，需要在类型声明文件中先引用原有模块，再使用 declare module 扩展原有模块</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// types/moment-plugin/index.d.ts

import * as moment from 'moment';

declare module 'moment' {
    export function foo(): moment.CalendarKey;
}


// src/index.ts

import * as moment from 'moment';
import 'moment-plugin';

moment.foo();
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h5 id="_7-声明文件中的依赖"><a href="#_7-声明文件中的依赖" class="header-anchor">#</a> 7）声明文件中的依赖</h5> <p>除了可以在声明文件中通过 import 导入另一个声明文件中的类型之外，还有一个语法也可以用来导入另一个声明文件，那就是三斜线指令</p> <h6 id="三斜线指令"><a href="#三斜线指令" class="header-anchor">#</a> 三斜线指令</h6> <p>与 namespace 类似，三斜线指令也是 ts 在早期版本中为了描述模块之间的依赖关系而创造的语法。随着 ES6 的广泛应用，现在已经不建议再使用 ts 中的三斜线指令来声明模块之间的依赖关系了。</p> <p>但是在声明文件中，它还是有一定的用武之地。</p> <p>类似于声明文件中的 import，它可以用来导入另一个声明文件。与 import 的区别是，当且仅当在以下几个场景下，我们才需要使用三斜线指令替代 import</p> <ul><li>当我们在书写一个全局变量的声明文件时</li> <li>当我们需要依赖一个全局变量的声明文件时</li></ul> <p><strong>书写一个全局变量的声明文件</strong></p> <p>在全局变量的声明文件中，是不允许出现 import, export 关键字的。一旦出现了，那么他就会被视为一个 npm 包或 UMD 库，就不再是全局变量的声明文件了。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// types/jquery-plugin/index.d.ts

/// &lt;reference types=&quot;jquery&quot; /&gt;

declare function foo(options: JQuery.AjaxSettings): string;


// src/index.ts

foo({});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>三斜线指令的语法如上，/// 后面使用 xml 的格式添加了对 jquery 类型的依赖，这样就可以在声明文件中使用 JQuery.AjaxSettings 类型了。</p> <p>注意，三斜线指令必须放在文件的最顶端</p> <p><strong>依赖一个全局变量的声明文件</strong>
在另一个场景下，当我们需要依赖一个全局变量的声明文件时，由于全局变量不支持通过 import 导入，当然也就必须使用三斜线指令</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>/ types/node-plugin/index.d.ts
/// &lt;reference types=&quot;node&quot; /&gt;
export function foo(p: NodeJS.Process): string;


// src/index.ts
import { foo } from 'node-plugin';
foo(global.process);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>以上两种使用场景下，都是由于需要书写或需要依赖全局变量的声明文件，所以必须使用三斜线指令。</p> <p><strong>拆分声明文件</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// node_modules/@types/jquery/index.d.ts

/// &lt;reference types=&quot;sizzle&quot; /&gt;
/// &lt;reference path=&quot;JQueryStatic.d.ts&quot; /&gt;
/// &lt;reference path=&quot;JQuery.d.ts&quot; /&gt;
/// &lt;reference path=&quot;misc.d.ts&quot; /&gt;
/// &lt;reference path=&quot;legacy.d.ts&quot; /&gt;

export = jQuery;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>其中用到了 types 和 path 两种不同的指令。它们的区别是：types 用于声明对另一个库的依赖，而 path 用于声明对另一个文件的依赖。</p> <h5 id="_8-自动生成声明文件"><a href="#_8-自动生成声明文件" class="header-anchor">#</a> 8）自动生成声明文件</h5> <p>如果库的源码本身就是由 ts 写的，那么在使用 tsc 脚本将 ts 编译为 js 的时候，添加 declaration 选项，就可以同时也生成 .d.ts 声明文件了。</p> <p>我们可以在命令行中添加 --declaration（简写 -d），或者在 tsconfig.json 中添加 declaration 选项。这里以 tsconfig.json 为例</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>{
    &quot;compilerOptions&quot;: {
        &quot;module&quot;: &quot;commonjs&quot;,
        &quot;outDir&quot;: &quot;lib&quot;,
        &quot;declaration&quot;: true,
    }
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="_5-发布声明文件"><a href="#_5-发布声明文件" class="header-anchor">#</a> 5.发布声明文件</h4> <ul><li>将声明文件和源码放在一起</li> <li>将声明文件发布到 @types 下</li></ul> <h5 id="_1-将声明文件和源码放在一起"><a href="#_1-将声明文件和源码放在一起" class="header-anchor">#</a> 1）将声明文件和源码放在一起</h5> <h3 id="_6-内置对象"><a href="#_6-内置对象" class="header-anchor">#</a> 6.内置对象</h3> <p>JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。</p> <p>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。</p> <h4 id="_1-ecmascript-的内置对象"><a href="#_1-ecmascript-的内置对象" class="header-anchor">#</a> 1）ECMAScript 的内置对象</h4> <p>CMAScript 标准提供的内置对象有：</p> <p>Boolean、Error、Date、RegExp 等。</p> <p>我们可以在 TypeScript 中将变量定义为这些类型</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let b: Boolean = new Boolean(1);
let e: Error = new Error('Error occurred');
let d: Date = new Date();
let r: RegExp = /[a-z]/;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>而他们的定义文件，则在 <a href="https://github.com/Microsoft/TypeScript/tree/main/src/lib" target="_blank" rel="noopener noreferrer">TypeScript 核心库的定义文件<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中</p> <h4 id="_2-dom-和-bom-的内置对象"><a href="#_2-dom-和-bom-的内置对象" class="header-anchor">#</a> 2）DOM 和 BOM 的内置对象</h4> <p>DOM 和 BOM 提供的内置对象有：</p> <p>Document、HTMLElement、Event、NodeList 等。</p> <p>TypeScript 中会经常用到这些类型：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let body: HTMLElement = document.body;
let allDiv: NodeList = document.querySelectorAll('div');
document.addEventListener('click', function(e: MouseEvent) {
  // Do something
});
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><a href="https://github.com/Microsoft/TypeScript/tree/main/src/lib" target="_blank" rel="noopener noreferrer">TypeScript 核心库的定义文件<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中</p> <h4 id="_3-typescript-核心库的定义文件"><a href="#_3-typescript-核心库的定义文件" class="header-anchor">#</a> 3）TypeScript 核心库的定义文件</h4> <p>TypeScript 核心库的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。</p> <p>当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，比如</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Math.pow(10, '2');

// index.ts(1,14): error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>上面的例子中，Math.pow 必须接受两个 number 类型的参数。事实上 Math.pow 的类型定义如下：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Math {
    /**
     * Returns the value of a base expression taken to a specified power.
     * @param x The base value of the expression.
     * @param y The exponent value of the expression.
     */
    pow(x: number, y: number): number;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>DOM 中的例子</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>document.addEventListener('click', function(e) {
    console.log(e.targetCurrent);
});

// index.ts(2,17): error TS2339: Property 'targetCurrent' does not exist on type 'MouseEvent'.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>上面的例子中，addEventListener 方法是在 TypeScript 核心库中定义的</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>interface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent {
    addEventListener(type: string, listener: (ev: MouseEvent) =&gt; any, useCapture?: boolean): void;
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>所以 e 被推断成了 MouseEvent，而 MouseEvent 是没有 targetCurrent 属性的，所以报错了。</p> <p>注意，TypeScript 核心库的定义中不包含 Node.js 部分</p> <h4 id="_4-用-typescript-写-node-js"><a href="#_4-用-typescript-写-node-js" class="header-anchor">#</a> 4）用 TypeScript 写 Node.js</h4> <p>Node.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>npm install @types/node --save-dev
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></div></div> <!----> <div class="page-edit"><!----> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2024/09/29, 18:35:30</span></div></div> <div class="page-nav-wapper"><!----> <!----></div></div> <div class="article-list"><div class="article-title"><a href="/blog/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/blog/pages/1678441859170/"><div>
            vue2 升级vue3 路线
            <!----></div></a> <span class="date">02-20</span></dt></dl><dl><dd>02</dd> <dt><a href="/blog/pages/175c51/"><div>
            argo原理
            <span class="title-tag">
              原创
            </span></div></a> <span class="date">09-21</span></dt></dl><dl><dd>03</dd> <dt><a href="/blog/pages/bc3411/"><div>
            低代码平台
            <!----></div></a> <span class="date">09-01</span></dt></dl> <dl><dd></dd> <dt><a href="/blog/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:990235922@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/Alan0827" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2016-2024
    <span>Alan0827</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <div class="body-bg" style="background:url() center center / cover no-repeat;opacity:0.5;"></div> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/blog/assets/js/app.c4ef267f.js" defer></script><script src="/blog/assets/js/2.738e1f2a.js" defer></script><script src="/blog/assets/js/76.d305a829.js" defer></script>
  </body>
</html>
