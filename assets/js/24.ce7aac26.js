(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{349:function(e,n,t){"use strict";t.r(n);var a=t(4),v=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h4",{attrs:{id:"事件模型以及周边"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事件模型以及周边"}},[e._v("#")]),e._v(" 事件模型以及周边")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("事件捕获")])]),e._v(" "),n("li",[n("p",[e._v("事件冒泡")])]),e._v(" "),n("li",[n("p",[e._v("事件触发")])]),e._v(" "),n("li",[n("p",[e._v("移动端事件模拟")])]),e._v(" "),n("li",[n("p",[e._v("事件委托")])])]),e._v(" "),n("h4",{attrs:{id:"事件捕获-事件冒泡"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事件捕获-事件冒泡"}},[e._v("#")]),e._v(" 事件捕获&事件冒泡")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('<div class="out">\n    <p class="inner"></p>\n</div>\n')])])]),n("blockquote",[n("p",[e._v("给inner,out均绑定点击事件.点击inner,如果out先执行,inner后执行.则是事件捕获.若inner先执行.out后执行则是事件冒泡.(这两种模型来自于早期浏览器之争)")])]),e._v(" "),n("p",[e._v("W3C模型")]),e._v(" "),n("blockquote",[n("p",[e._v("先事件捕获,到达目标后再进行冒泡")])]),e._v(" "),n("p",[e._v("示例演示")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("out.addEventListener('click', (e) => {\n    console.log('out clicked! ')\n}, true)\ninner.addEventListener('click', (e) => {\n    console.log('inner clicked! ')\n}, false)\ndocument.addEventListener('click', (e) => {\n    console.log('document clicked! ')\n}, true)\n")])])]),n("p",[e._v("点击inner后,执行顺序:document clicked => out clicked => inner clicked")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("out.addEventListener('click', (e) => {\n    console.log('out clicked! ')\n}, true)\ninner.addEventListener('click', (e) => {\n    console.log('inner clicked! ')\n}, false)\ndocument.addEventListener('click', (e) => {\n    console.log('document clicked! ')\n}, false)\n")])])]),n("p",[e._v("点击inner后,执行顺序: out clicked => inner clicked => document clicked")]),e._v(" "),n("h4",{attrs:{id:"事件模型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事件模型"}},[e._v("#")]),e._v(" 事件模型")]),e._v(" "),n("p",[e._v("1.DOM0级事件(默认发生在冒泡阶段.只能绑定一个事件)")]),e._v(" "),n("p",[e._v("事件绑定")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("ele.onclick = function (){\n    //\n}\n")])])]),n("p",[e._v("事件解除绑定")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("ele.onclick = null;\n")])])]),n("p",[e._v("2.DOM2级事件(默认发生在冒泡阶段,由第三个参数决定,可绑定多个事件)")]),e._v(" "),n("p",[e._v("事件绑定")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("ele.addEventListener(eventType, handler, useCapture)//eventType不带on,如click\n//IE下用attachEvent\nele.attachEvent(eventType, handler);\n")])])]),n("p",[e._v("事件解除绑定")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("ele.removeEventListener(eventType, handler, useCapture)\n//IE下使用detachEvent\nele.detachEvent(eventType, handler);\n")])])]),n("h4",{attrs:{id:"事件对象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#事件对象"}},[e._v("#")]),e._v(" 事件对象")]),e._v(" "),n("p",[e._v("DOM事件模型中的事件对象常用属性:")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("type用于获取事件类型")])]),e._v(" "),n("li",[n("p",[e._v("target获取事件目标")])]),e._v(" "),n("li",[n("p",[e._v("stopPropagation()阻止事件冒泡")])]),e._v(" "),n("li",[n("p",[e._v("preventDefault()阻止事件默认行为")])])]),e._v(" "),n("p",[e._v("IE事件模型中的事件对象常用属性:")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("srcElement获取事件目标")])]),e._v(" "),n("li",[n("p",[e._v("cancelBubble阻止事件冒泡")])]),e._v(" "),n("li",[n("p",[e._v("returnValue阻止事件默认行为")])])]),e._v(" "),n("p",[e._v("兼容处理")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("var eventUtil = {\n    addEvent: function(ele, event, func, bool) {\n        bool = bool || false;\n        if (ele.addEventListener) {\n            ele.addEventListener(event, func, bool)\n        } else {\n            ele.attachEvent('on' + event, func, bool);\n        }\n    },\n    removeEvent: function(ele, event, func, bool) {\n        bool = bool || false;\n        if (ele.removeEventListener) {\n            ele.removeEventListener(event, func, bool);\n        } else {\n            ele.detachEvent('on' + event, func, bool);\n        }\n    },\n    getEvent: function(event) {\n        return event || window.event;\n    },\n    getTarget: function(event) {\n        return event.target || event.srcElement;\n    },\n    preventDefault:function (event) {\n        if (event.preventDefault) {\n            event.preventDefault();\n        }else {\n            event.returnValue = false;//IE\n        }\n    },\n    stopPropagation:function  (event) {\n        if (event.stopPropagation) {\n            event.stopPropagation();\n        } else {\n            event.cancelBubble = true;//IE\n        }\n    }\n};\n")])])]),n("h4",{attrs:{id:"移动端事件"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#移动端事件"}},[e._v("#")]),e._v(" 移动端事件")]),e._v(" "),n("p",[e._v("Touch事件")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("touchstart:当手指触摸屏幕时触发；即使已经有一个手指放在了屏幕上也会触发。\ntouchmove:当手指在屏幕上滑动时连续的触发。在这个事件发生期间，调用preventDefault()可阻止滚动\n")])])]),n("p",[e._v("touchend:当手指从屏幕上移开时触发。\ntouchcancel:当系统停止跟踪触摸时触发。关于此事件的确切触发事件，文档中没有明确说明。\n以上事件的event对象上面都存在如下属性：\ntouches:表示当前跟踪的触摸操作的Touch对象的数组。\ntargetTouches:特定于事件目标的Touch对象的数组。\nchangeTouches:表示自上次触摸以来发生了什么改变的Touch对象的数组。")]),e._v(" "),n("p",[e._v("每个Touch对象包含下列属性：\nidentifier：表示触摸的唯一ID。")]),e._v(" "),n("p",[e._v("clientX:触摸目标在视口中的X坐标。\nclientY:触摸目标在视口中的Y坐标。\npageX：触摸目标在页面中的x坐标。\npageY：触摸目标在页面中的y坐标。\nscreenX:触摸目标在屏幕中的x坐标。\nscreenY:触摸目标在屏幕中的y坐标。\ntarget:触摸的DOM节点坐标")]),e._v(" "),n("p",[e._v("触发过程")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("touchstart =>touchmove =>touchend =>click(延迟300~200ms)\n\nTap事件封装原理:利用touchstart =>touchmove =>touchen模拟click\n\nHTMLElement.prototype.tap = function (handler,interval) {\n    that = this\n    this.isMove = false,\n    this.startTime = 0,\n    this.addEventListener('touchstart',function(e){\n            startTime = Date.now();\n        }),\n    this.addEventListener('touchmove',function(e){\n            isMove = true;\n        }),\n    this.addEventListener('touchend',function(e){\n            if(!this.isMove && (Date.now()-startTime) < interval){\n                handler();\n            }\n            this.isMove = false;\n            this.startTime = 0;\n        })\n};\n")])])]),n("p",[e._v("事件委托")]),e._v(" "),n("p",[e._v("把本应绑定在自身的事件绑定到其他元素上来触发即事件委托")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('//HTML\n<ul id="ul">\n    <li>a</li>\n    <li>b</li>\n</ul>\n\n//JS\n    var oUl = document.getElementById("ul");\n    oUl.onmouseover = function(ev){\n        var ev = ev || window.event;\n        var target = ev.target || ev.srcElement;\n        if((/l\\i/i).test(target.nodeName)){\n        target.style.background = "red";\n        }\n    }\n    oUl.onmouseout = function(ev){\n        var ev = ev || window.event;\n        var target = ev.target || ev.srcElement;\n        if((/l\\i/i).test(target.nodeName)){\n            target.style.background = "";\n        }\n    }\n//JS\n')])])]),n("p",[e._v("感谢源著作者   https://segmentfault.com/a/1190000008774838")])])}),[],!1,null,null,null);n.default=v.exports}}]);